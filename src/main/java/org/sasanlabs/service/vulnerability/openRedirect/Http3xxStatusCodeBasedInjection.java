package org.sasanlabs.service.vulnerability.openRedirect;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Set;

public class Http3xxStatusCodeBasedInjection {

    private static final Set<String> ALLOWED_PATHS = Set.of("/home", "/profile", "/help");
    private static final Set<String> TRUSTED_HOSTS = Set.of("trusted.example.com", "another-trusted.com");

    public ResponseEntity<Void> safeRedirect(String target) {
        if (target == null || target.isBlank()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }

        // Relative path: προτιμούμε μόνο relative και whitelist
        if (target.startsWith("/")) {
            if (!ALLOWED_PATHS.contains(target)) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            }
            URI uri = URI.create(target);
            HttpHeaders headers = new HttpHeaders();
            headers.setLocation(uri);
            return new ResponseEntity<>(headers, HttpStatus.FOUND);
        }

        // Absolute URL: validate host
        try {
            URI uri = new URI(target);
            String host = uri.getHost();
            if (host == null || !TRUSTED_HOSTS.contains(host)) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            }
            HttpHeaders headers = new HttpHeaders();
            headers.setLocation(uri);
            return new ResponseEntity<>(headers, HttpStatus.FOUND);
        } catch (URISyntaxException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }
}

